<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Bandar Detector â€“ Clipboard + Haka Haki + Summary</title>
<style>
    body {
        font-family: Arial, sans-serif;
        margin: 20px;
        background: #0f172a;
        color: #e5e7eb;
    }
    h2, h3 {
        margin: 0 0 8px 0;
    }
    p {
        margin-top: 4px;
        margin-bottom: 12px;
        color: #cbd5f5;
    }
    textarea {
        width: 100%;
        height: 140px;
        padding: 10px;
        font-size: 13px;
        border-radius: 8px;
        border: 1px solid #1f2937;
        box-sizing: border-box;
        background: #020617;
        color: #e5e7eb;
    }
    textarea:focus {
        outline: none;
        border-color: #3b82f6;
        box-shadow: 0 0 0 1px #3b82f6;
    }
    table {
        border-collapse: collapse;
        width: 100%;
        margin-top: 10px;
        background: #020617;
        border-radius: 8px;
        overflow: hidden;
    }
    th, td {
        border: 1px solid #111827;
        padding: 6px;
        text-align: center;
        font-size: 11px;
        color: #e5e7eb;
    }
    th {
        background: #111827;
        color: #f9fafb;
        position: sticky;
        top: 0;
        z-index: 5;
    }

    /* Freeze header for result table */
    #resultTable thead th {
        position: sticky;
        top: 0;
        background: #111827;
        color: #f9fafb;
        z-index: 6;
    }

    /* Broker selector chips / input */
    .broker-selector {
        margin-top:10px;
        display:flex;
        gap:8px;
        align-items:center;
        flex-wrap:wrap;
    }
    .broker-input {
        flex:1;
        display:flex;
        gap:6px;
    }
    .broker-input input {
        flex:1;
        padding:6px 8px;
        border-radius:6px;
        border:1px solid #374151;
        background:#0b1220;
        color:#e5e7eb;
    }
    .broker-input button {
        padding:6px 10px;
        border-radius:6px;
        border:1px solid #3b82f6;
        background:#3b82f6;
        color:#fff;
        cursor:pointer;
    }
    .broker-chips {
        display:flex;
        gap:6px;
        flex-wrap:wrap;
        margin-top:8px;
    }
    .chip {
        background:#111827;
        color:#e5e7eb;
        padding:6px 8px;
        border-radius:999px;
        font-size:12px;
        display:inline-flex;
        align-items:center;
        gap:8px;
        border:1px solid #374151;
    }
    .chip .remove {
        cursor:pointer;
        opacity:0.8;
        padding-left:6px;
    }

    .haka { background: #0b3b6b; }
    .haki { background: #5a1f2d; }
    .cross { background: #3b255c; }

    .legend-box {
        display:inline-block;
        width:14px;
        height:14px;
        margin-right:4px;
        vertical-align:middle;
        border-radius: 3px;
    }
    .legend-haka { background:#0b3b6b; }
    .legend-haki { background:#5a1f2d; }
    .legend-cross{ background:#3b255c; }

    .layout-row {
        display:flex;
        gap:20px;
        align-items:flex-start;
        margin-top:20px;
    }
    .layout-left {
        flex:2;
        background:#020617;
        border-radius:12px;
        padding:12px;
        border:1px solid #1f2937;
    }
    .layout-right {
        flex:1;
        box-sizing:border-box;
        background:#020617;
        border-radius:12px;
        padding:12px;
        border:1px solid #1f2937;
    }
    .layout-right h3,
    .layout-left h3 {
        font-size:14px;
        margin-bottom:6px;
        color:#bfdbfe;
    }

    .summary-tabs {
        margin-bottom:6px;
    }
    .summary-tabs button {
        font-size:11px;
        padding:4px 10px;
        margin-right:4px;
        border-radius:999px;
        border:1px solid #374151;
        background:#020617;
        color:#9ca3af;
        cursor:pointer;
    }
    .summary-tabs button.active {
        background:#3b82f6;
        color:#f9fafb;
        border-color:#3b82f6;
    }

    tr.selected-row td {
        background: #78350f !important;
    }

    #selectionSummary {
        position: fixed;
        right: 20px;
        bottom: 20px;
        background: rgba(15, 23, 42, 0.95);
        color: #f9fafb;
        padding: 10px 14px;
        border-radius: 10px;
        font-size: 12px;
        box-shadow: 0 2px 14px rgba(0,0,0,0.65);
        display: none;
        z-index: 999;
        max-width: 260px;
        border: 1px solid #4b5563;
    }
    #selectionSummary b {
        font-size: 12px;
    }
</style>
</head>
<body>

<h2>ðŸ“ˆ Bandar Detector â€“ Haka / Haki / Dominant Broker</h2>
<p>
Paste broker summary (<code>Time Stock Brd Price Qty BT BC SC ST</code>) â†’ klik textarea â†’ <b>CTRL+V</b>.
</p>

<textarea id="pasteArea" placeholder="Paste data broker summary di sini..."></textarea>

<div class="layout-row">
    <div class="layout-left">
        <h3>ðŸ“Š Line Chart â€“ Net Volume per Broker + Price</h3>
        <canvas id="chartBrokerDom" height="160"></canvas>

        <!-- Broker selector UI -->
        <div id="brokerSelector" class="broker-selector">
            <div class="broker-input">
                <input id="brokerInput" placeholder="Tambah broker (kode), tekan Enter atau tombol +" />
                <button id="addBrokerBtn">+</button>
            </div>
            <div id="brokerChips" class="broker-chips"></div>
        </div>
    </div>
    <div class="layout-right">
        <h3>ðŸ§¾ Broker Summary (Gross / Net)</h3>
        <div class="summary-tabs">
            <button id="tabGross" class="active">Gross</button>
            <button id="tabNet">Net</button>
        </div>
        <table id="summaryTable">
            <thead>
                <tr id="summaryHeader"></tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>
</div>

<h3 style="margin-top:30px;">ðŸ“Š Qty per Time + Price</h3>
<div style="background:#020617;border-radius:12px;padding:12px;border:1px solid #1f2937;">
    <canvas id="chartTime" height="140"></canvas>
</div>

<div style="margin-top:20px;background:#020617;border-radius:12px;padding:10px;border:1px solid #1f2937;">
    <b>Legend warna baris transaksi:</b><br>
    <span class="legend-box legend-haka"></span>ðŸŸ¦ Haka (Buyer cluster â€“ banyak transaksi broker yang sama di sisi BC dalam 1 detik)<br>
    <span class="legend-box legend-haki"></span>ðŸŸ¥ Haki (Seller cluster â€“ banyak transaksi broker yang sama di sisi SC dalam 1 detik)<br>
    <span class="legend-box legend-cross"></span>ðŸŸª Cross / Haka-Haki (broker aktif di sisi BC dan SC dalam detik yang sama)<br>
</div>

<h3 style="margin-top:20px;">ðŸ“œ Detail Transaksi</h3>
<div class="filters" style="margin-bottom:10px;background:#020617;border-radius:8px;padding:10px;border:1px solid #1f2937;">
  <span style="color:#bfdbfe;">Filters:</span><br>
  Lot: <input type="text" id="lotFilter" placeholder="e.g. >1000" style="margin:5px; background:#111827;color:#e5e7eb;border:1px solid #374151;border-radius:4px;padding:4px;width:120px;">
  BC/SC: <input type="text" id="brokerFilter" placeholder="Broker code" style="margin:5px; background:#111827;color:#e5e7eb;border:1px solid #374151;border-radius:4px;padding:4px;width:120px;">
  Start Time: <input type="time" id="startTimeFilter" step="1" style="margin:5px; background:#111827;color:#e5e7eb;border:1px solid #374151;border-radius:4px;padding:4px;">
  End Time: <input type="time" id="endTimeFilter" step="1" style="margin:5px; background:#111827;color:#e5e7eb;border:1px solid #374151;border-radius:4px;padding:4px;">
  Manual Time: <input type="text" id="timeFilter" placeholder="HH:MM:SS - HH:MM:SS" style="margin:5px; background:#111827;color:#e5e7eb;border:1px solid #374151;border-radius:4px;padding:4px;width:180px;">
  <button id="applyFilter" style="margin:5px; background:#3b82f6;color:#f9fafb;border:1px solid #3b82f6;border-radius:4px;padding:4px 8px;">Apply</button>
</div>
<div style="max-height:420px;overflow:auto;border-radius:12px;border:1px solid #1f2937;background:#020617;">
<table id="resultTable">
    <thead>
        <tr>
            <th>Time</th>
            <th>Stock</th>
            <th>Price</th>
            <th>Qty (Lot)</th>
            <th>Value (IDR)</th>
            <th>Group Value (Tag)</th>
            <th>BT</th>
            <th>BC (Buyer)</th>
            <th>SC (Seller)</th>
            <th>ST</th>
            <th>Tag</th>
        </tr>
    </thead>
    <tbody></tbody>
</table>
</div>

<div id="selectionSummary"></div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
let chartTimeObj = null;
let chartDomObj  = null;
let globalTimeStats = null;
let globalBrokerSummary = null;
let summaryMode = "gross";
let globalRows = null;

let selectionTimer = null;
let isMouseDown = false;
let didDrag = false;

// new: selected brokers for Net Volume chart (chips)
let selectedBrokers = [];

// ===== Broker color map (consistent) =====
const brokerColors = {};
const brokerPalette = [
    "#ef4444", "#22c55e", "#3b82f6", "#a855f7", "#f97316",
    "#eab308", "#14b8a6", "#f472b6", "#6366f1", "#84cc16",
    "#0ea5e9", "#fb7185", "#facc15", "#2dd4bf", "#4ade80"
];
function getBrokerColor(code) {
    if (!code) return "";
    if (brokerColors[code]) return brokerColors[code];
    const idx = Object.keys(brokerColors).length % brokerPalette.length;
    brokerColors[code] = brokerPalette[idx];
    return brokerColors[code];
}

function getTypeBg(type) {
    if (!type) return "";
    if (type === "D") return "#020617";
    if (type === "F" || type === "A") return "#854d0e"; // kuning kecoklat
    return "#854d0e";
}

// ===== PASTE HANDLER =====
document.getElementById("pasteArea").addEventListener("paste", function() {
    setTimeout(() => {
        const raw = this.value.trim();
        processData(raw);
    }, 50);
});

// Tabs gross/net
document.getElementById("tabGross").addEventListener("click", () => {
    summaryMode = "gross";
    setActiveTab();
    if (globalBrokerSummary) renderBrokerSummary(globalBrokerSummary);
});

document.getElementById("tabNet").addEventListener("click", () => {
    summaryMode = "net";
    setActiveTab();
    if (globalBrokerSummary) renderBrokerSummary(globalBrokerSummary);
});

function setActiveTab(){
    document.getElementById("tabGross").classList.toggle("active", summaryMode==="gross");
    document.getElementById("tabNet").classList.toggle("active", summaryMode==="net");
}

// Mouse up global â†’ akhiri drag
document.addEventListener("mouseup", function() {
    if (isMouseDown) {
        isMouseDown = false;
        scheduleSelectionSummaryUpdate();
    }
});

document.getElementById("applyFilter").addEventListener("click", function() {
    renderTable();
});

// ===== PARSE CLIPBOARD =====
function processData(rawText) {
    const lines = rawText.split("\n").filter(l => l.trim() !== "");
    const rows = [];

    lines.forEach((line, idx) => {
        const parts = line.trim().split(/\s+/);
        if (parts[0] === "Time" || parts.length < 9) return;

        const time  = parts[0];
        const stock = parts[1];
        const brd   = parts[2];
        const price = parseFloat(parts[3].replace(/,/g,"")) || 0;
        const qty   = parseInt(parts[4].replace(/,/g,"")) || 0;
        const BT    = parts[5];
        const BC    = parts[6];
        const SC    = parts[7];
        const ST    = parts[8];

        rows.push({
            idx,
            time,
            stock,
            brd,
            price,
            qty,
            BT,
            BC,
            SC,
            ST,
            tag: "",
            haka: false,
            haki: false,
            cross: false
        });
    });

    if (rows.length === 0) return;

    detectHakaHaki(rows);
    globalTimeStats = buildTimeStats(rows);
    globalBrokerSummary = buildBrokerSummary(rows);

    globalRows = rows;

    // set default selected brokers (5 net buy + 5 net sell) from summary
    setDefaultSelectedBrokers(globalBrokerSummary);

    renderTable();
    renderTimeChart(rows);
    renderDominantBrokerChart(rows);
    renderBrokerSummary(globalBrokerSummary);
    document.getElementById("selectionSummary").style.display = "none";
}

// new: set default selected brokers (top 5 net buy + top 5 net sell if available)
function setDefaultSelectedBrokers(list) {
    if (!Array.isArray(list)) return;
    const buys = list.filter(s => s.netVal > 0).sort((a,b)=>b.netVal - a.netVal).slice(0,5).map(s=>s.broker);
    const sells = list.filter(s => s.netVal < 0).sort((a,b)=>Math.abs(b.netVal) - Math.abs(a.netVal)).slice(0,5).map(s=>s.broker);
    const combined = Array.from(new Set([...buys, ...sells]));
    selectedBrokers = combined;
    renderBrokerChips();
}

// render chips UI
function renderBrokerChips() {
    const container = document.getElementById("brokerChips");
    container.innerHTML = "";
    selectedBrokers.forEach(b => {
        const chip = document.createElement("span");
        chip.className = "chip";
        chip.innerHTML = `<span style="font-weight:700;">${b}</span><span class="remove" data-b="${b}">âœ•</span>`;
        container.appendChild(chip);
    });

    // attach remove handlers
    container.querySelectorAll('.remove').forEach(el => {
        el.onclick = function() {
            const b = this.dataset.b;
            selectedBrokers = selectedBrokers.filter(x => x !== b);
            renderBrokerChips();
            if (globalRows) renderDominantBrokerChart(globalRows);
        };
    });
}

// add broker from input
document.getElementById("addBrokerBtn").addEventListener("click", addBrokerFromInput);
document.getElementById("brokerInput").addEventListener("keydown", function(e) {
    if (e.key === "Enter") {
        addBrokerFromInput();
        e.preventDefault();
    }
});

function addBrokerFromInput() {
    const el = document.getElementById("brokerInput");
    const code = (el.value || "").trim().toUpperCase();
    if (!code) return;
    if (!selectedBrokers.includes(code)) {
        selectedBrokers.push(code);
        renderBrokerChips();
        if (globalRows) renderDominantBrokerChart(globalRows);
    }
    el.value = "";
}

// ===== CHART: DOMINANT BROKER + PRICE =====
function renderDominantBrokerChart(rows) {
    const ctx = document.getElementById("chartBrokerDom").getContext("2d");

    const sorted = [...rows].sort((a,b) => timeToSec(a.time) - timeToSec(b.time));

    const brokerSet = new Set();
    sorted.forEach(r => {
        brokerSet.add(r.BC);
        brokerSet.add(r.SC);
    });

    const brokers = Array.from(brokerSet);
    const times   = [...new Set(sorted.map(r => r.time))].sort((a,b)=>timeToSec(a)-timeToSec(b));

    const cum = {};
    brokers.forEach(b => cum[b] = Array(times.length).fill(0));

    let lastCum = {};
    brokers.forEach(b => lastCum[b] = 0);

    times.forEach((t, idx) => {
        brokers.forEach(b => cum[b][idx] = lastCum[b]);
        sorted.filter(r => r.time === t).forEach(r => {
            lastCum[r.BC] += r.qty;
            lastCum[r.SC] -= r.qty;
        });
        brokers.forEach(b => cum[b][idx] = lastCum[b]);
    });

    // activity score fallback (previous behavior)
    const activity = brokers.map(b => ({
        broker: b,
        score: Math.max(...cum[b].map(v => Math.abs(v)))
    })).sort((a,b)=>b.score - a.score);

    // decide which brokers to show:
    let shownBrokers = [];
    if (selectedBrokers && selectedBrokers.length) {
        // keep only those present in cum (unknowns will be shown with zeros)
        shownBrokers = Array.from(new Set(selectedBrokers));
    } else {
        // fallback previous top activity (5)
        shownBrokers = activity.slice(0, 5).map(a => a.broker);
    }

    const datasets = shownBrokers.map(b => {
        const col = getBrokerColor(b);
        const data = (cum[b] !== undefined) ? cum[b] : Array(times.length).fill(0);
        return {
            label: b,
            data,
            yAxisID: "y",
            borderWidth: 2,
            fill: false,
            borderColor: col,
            backgroundColor: col,
            tension: 0.25
        };
    });

    const ts = globalTimeStats || buildTimeStats(rows);

    datasets.push({
        label: "Price (VWAP)",
        data: ts.times.map(t => {
            const idx = ts.times.indexOf(t);
            return idx >= 0 ? ts.prices[idx] : null;
        }),
        yAxisID: "y1",
        borderWidth: 1.5,
        borderDash: [6,4],
        fill: false,
        borderColor: "#9ca3af",
        tension: 0.25
    });

    if (chartDomObj) chartDomObj.destroy();

    chartDomObj = new Chart(ctx, {
        type: "line",
        data: {
            labels: times,
            datasets
        },
        options: {
            plugins: {
                legend: { labels: { color:"#e5e7eb" } }
            },
            interaction: { mode: "index", intersect: false },
            stacked: false,
            scales: {
                x: { ticks:{ color:"#9ca3af" }, grid:{ color:"#1f2937" } },
                y: {
                    type: "linear",
                    position: "left",
                    title: { display: true, text: "Net Volume (Lot)", color:"#e5e7eb" },
                    ticks: { color:"#9ca3af" },
                    grid: { color:"#111827" }
                },
                y1: {
                    type: "linear",
                    position: "right",
                    title: { display: true, text: "Price", color:"#e5e7eb" },
                    ticks: { color:"#9ca3af" },
                    grid: { drawOnChartArea: false, color:"#111827" }
                }
            }
        }
    });
}

// ===== HAKA / HAKI DETECTION =====
function detectHakaHaki(rows) {
    if (!Array.isArray(rows)) return;
    // group rows per time
    const byTime = {};
    rows.forEach(r => {
        if (!byTime[r.time]) byTime[r.time] = [];
        byTime[r.time].push(r);
    });

    Object.values(byTime).forEach(group => {
        // count occurrences per broker on BC and SC
        const countBC = {};
        const countSC = {};
        group.forEach(r => {
            if (r.BC) countBC[r.BC] = (countBC[r.BC] || 0) + 1;
            if (r.SC) countSC[r.SC] = (countSC[r.SC] || 0) + 1;
        });

        // brokers present on both sides in this second
        const bcBrokers = new Set(Object.keys(countBC));
        const scBrokers = new Set(Object.keys(countSC));
        const crossBrokers = new Set([...bcBrokers].filter(b => scBrokers.has(b)));

        group.forEach(r => {
            const isHaka = !!(r.BC && countBC[r.BC] > 1);
            const isHaki = !!(r.SC && countSC[r.SC] > 1);
            const isCross = crossBrokers.size > 0 && (crossBrokers.has(r.BC) || crossBrokers.has(r.SC));

            r.haka = isHaka;
            r.haki = isHaki;
            r.cross = isCross;

            if (isCross) r.tag = "Cross / Haka-Haki";
            else if (isHaka) r.tag = "Haka (Buy cluster)";
            else if (isHaki) r.tag = "Haki (Sell cluster)";
            else r.tag = "-";
        });
    });
}

// ===== AGGREGATION HELPERS (fix: add buildTimeStats & buildBrokerSummary) =====
function buildTimeStats(rows) {
    const byTime = {};
    rows.forEach(r => {
        if (!byTime[r.time]) byTime[r.time] = { qty: 0, value: 0 };
        const v = (r.qty || 0) * (r.price || 0) * 100;
        byTime[r.time].qty += (r.qty || 0);
        byTime[r.time].value += v;
    });

    const times = Object.keys(byTime).sort((a,b) => timeToSec(a) - timeToSec(b));
    const prices = [];
    const volumes = [];

    times.forEach(t => {
        const g = byTime[t];
        volumes.push(g.qty);
        // VWAP per time: total value / (qty * 100)  (reverse of value = qty * price * 100)
        prices.push(g.qty ? (g.value / (g.qty * 100)) : null);
    });

    return { times, prices, volumes };
}

function buildBrokerSummary(rows) {
    const map = {};
    rows.forEach(r => {
        const v = (r.qty || 0) * (r.price || 0) * 100;
        if (r.BC) {
            if (!map[r.BC]) map[r.BC] = { broker: r.BC, buyQty: 0, buyVal: 0, sellQty: 0, sellVal: 0 };
            map[r.BC].buyQty += (r.qty || 0);
            map[r.BC].buyVal += v;
        }
        if (r.SC) {
            if (!map[r.SC]) map[r.SC] = { broker: r.SC, buyQty: 0, buyVal: 0, sellQty: 0, sellVal: 0 };
            map[r.SC].sellQty += (r.qty || 0);
            map[r.SC].sellVal += v;
        }
    });

    const list = Object.values(map).map(s => ({
        broker: s.broker,
        buyQty: s.buyQty,
        sellQty: s.sellQty,
        buyVal: s.buyVal,
        sellVal: s.sellVal,
        netQty: s.buyQty - s.sellQty,
        netVal: s.buyVal - s.sellVal
    }));

    // sort by absolute net value (largest movers first)
    list.sort((a,b) => Math.abs(b.netVal) - Math.abs(a.netVal));
    return list;
}

// ===== RENDER / UI HELPERS (restored) =====

// Debounced selection summary
function scheduleSelectionSummaryUpdate() {
    if (selectionTimer) clearTimeout(selectionTimer);
    selectionTimer = setTimeout(updateSelectionSummary, 120);
}

function updateSelectionSummary() {
    const sel = document.querySelectorAll('#resultTable tbody tr.selected-row');
    if (!sel || sel.length === 0) {
        document.getElementById('selectionSummary').style.display = 'none';
        return;
    }
    let totalQty = 0, totalVal = 0;
    sel.forEach(tr => {
        totalQty += Number(tr.dataset.qty) || 0;
        totalVal += Number(tr.dataset.value) || 0;
    });
    const el = document.getElementById('selectionSummary');
    el.innerHTML = `<b>Selected</b><br>Qty: ${formatNumber(totalQty)}<br>Value: ${formatIdr(totalVal)}`;
    el.style.display = 'block';
}

// Render time chart (volume + price)
function renderTimeChart(rows) {
    const ctx = document.getElementById('chartTime').getContext('2d');
    const ts = buildTimeStats(rows || globalRows || []);
    if (chartTimeObj) chartTimeObj.destroy();
    chartTimeObj = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: ts.times,
            datasets: [
                {
                    type: 'bar',
                    label: 'Qty (Lot)',
                    data: ts.volumes,
                    backgroundColor: '#3b82f6',
                    yAxisID: 'y'
                },
                {
                    type: 'line',
                    label: 'Price (VWAP)',
                    data: ts.prices,
                    borderColor: '#f9fafb',
                    backgroundColor: '#f9fafb',
                    yAxisID: 'y1',
                    fill: false,
                    tension: 0.25
                }
            ]
        },
        options: {
            plugins: { legend: { labels: { color:"#e5e7eb" } } },
            scales: {
                x: { ticks:{ color:"#9ca3af" }, grid:{ color:"#1f2937" } },
                y: { position:'left', title:{ display:true, text:'Qty (Lot)', color:"#e5e7eb" }, ticks:{ color:"#9ca3af" }, grid:{ color:"#111827" } },
                y1: { position:'right', title:{ display:true, text:'Price', color:"#e5e7eb" }, ticks:{ color:"#9ca3af" }, grid:{ drawOnChartArea:false } }
            }
        }
    });
}

// Render broker summary table
function renderBrokerSummary(list) {
    const table = document.getElementById('summaryTable');
    const thead = table.querySelector('thead tr#summaryHeader');
    const tbody = table.querySelector('tbody');
    thead.innerHTML = '';
    tbody.innerHTML = '';

    if (!Array.isArray(list) || list.length === 0) {
        thead.innerHTML = '<th>Broker</th><th>No data</th>';
        return;
    }

    // header
    if (summaryMode === 'gross') {
        thead.innerHTML = '<th>Broker</th><th>Buy Qty</th><th>Buy Val</th><th>Sell Qty</th><th>Sell Val</th><th>Net Qty</th><th>Net Val</th>';
        list.forEach(r => {
            const tr = document.createElement('tr');
            tr.innerHTML = `<td style="font-weight:700;">${r.broker}</td>
                            <td>${formatNumber(r.buyQty)}</td>
                            <td>${formatIdr(r.buyVal)}</td>
                            <td>${formatNumber(r.sellQty)}</td>
                            <td>${formatIdr(r.sellVal)}</td>
                            <td>${formatNumber(r.netQty)}</td>
                            <td>${formatIdr(r.netVal)}</td>`;
            tbody.appendChild(tr);
        });
    } else {
        // net mode
        thead.innerHTML = '<th>Broker</th><th>Net Qty</th><th>Net Val</th>';
        list.forEach(r => {
            const tr = document.createElement('tr');
            tr.innerHTML = `<td style="font-weight:700;">${r.broker}</td>
                            <td>${formatNumber(r.netQty)}</td>
                            <td>${formatIdr(r.netVal)}</td>`;
            tbody.appendChild(tr);
        });
    }
}

// Render main transaction table with filters and group recalculation
function renderTable() {
    if (!Array.isArray(globalRows)) return;
    const tbody = document.querySelector('#resultTable tbody');
    tbody.innerHTML = '';

    // apply filters
    let filtered = [...globalRows];

    // Lot filter
    const lotFilter = (document.getElementById('lotFilter') || {}).value || '';
    if (lotFilter.trim()) {
        const f = lotFilter.trim();
        if (f.startsWith('>') || f.startsWith('<') || f.startsWith('=')) {
            const op = f[0];
            const num = parseFloat(f.slice(1));
            if (!isNaN(num)) {
                filtered = filtered.filter(r => {
                    if (op === '>') return r.qty > num;
                    if (op === '<') return r.qty < num;
                    return r.qty === num;
                });
            }
        } else {
            const num = parseFloat(f);
            if (!isNaN(num)) filtered = filtered.filter(r => r.qty === num);
        }
    }

    // Broker filter (BC/SC)
    const brokerFilter = ((document.getElementById('brokerFilter') || {}).value || '').trim().toUpperCase();
    if (brokerFilter) {
        filtered = filtered.filter(r => ((r.BC||'').toUpperCase().includes(brokerFilter) || (r.SC||'').toUpperCase().includes(brokerFilter)));
    }

    // time filters
    const st = (document.getElementById('startTimeFilter') || {}).value;
    const et = (document.getElementById('endTimeFilter') || {}).value;
    if (st) {
        const ssec = timeToSec(st);
        filtered = filtered.filter(r => timeToSec(r.time) >= ssec);
    }
    if (et) {
        const esec = timeToSec(et);
        filtered = filtered.filter(r => timeToSec(r.time) <= esec);
    }

    // Manual time range (HH:MM:SS - HH:MM:SS)
    const manualTime = (document.getElementById('timeFilter') || {}).value || '';
    if (manualTime.includes('-')) {
        const [start, end] = manualTime.split('-').map(t => t.trim());
        if (start && end) {
            const startSec = timeToSec(start);
            const endSec = timeToSec(end);
            filtered = filtered.filter(r => {
                const sec = timeToSec(r.time);
                return sec >= startSec && sec <= endSec;
            });
        }
    }

    // update table
    tbody.innerHTML = '';
    filtered.forEach(r => {
        const tr = document.createElement('tr');
        tr.dataset.qty = r.qty;
        tr.dataset.value = (r.qty * r.price * 100);
        tr.innerHTML = `<td>${r.time}</td>
                        <td>${r.stock}</td>
                        <td>${formatNumber(r.price)}</td>
                        <td>${formatNumber(r.qty)}</td>
                        <td>${formatIdr(r.value)}</td>
                        <td>${formatIdr(r.groupValue)}</td>
                        <td>${r.BT}</td>
                        <td>${r.BC}</td>
                        <td>${r.SC}</td>
                        <td>${r.ST}</td>
                        <td>${r.tag}</td>`;
        tbody.appendChild(tr);
    });

    // re-render summary if needed
    if (summaryMode === "gross" && globalBrokerSummary) {
        renderBrokerSummary(globalBrokerSummary);
    } else if (summaryMode === "net" && globalBrokerSummary) {
        renderBrokerSummary(globalBrokerSummary);
    }
}
</script>

</body>
</html>
